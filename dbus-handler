#!/usr/in/python3

import os
import sys
import click
import pyudev as udev
import logging
import time
import re
import pwd
import anyio
import socket
from asyncdbus import MessageBus
from pprint import pprint
from pathlib import Path
from contextlib import suppress
from fnmatch import fnmatch

from yaml import safe_load as yload

logger = logging.getLogger("handler")

CFG = {}
cfg_time = 0

@click.command
@click.option("-c","--config",required=True,multiple=True,type=click.Path(file_okay=True,dir_okay=False,readable=True,exists=True),  help="Config file (YAML)")
@click.option("-v","--verbose",count=True, help="Be more verbose")
def main(config, verbose):
    """
    Process new Venus devices.

    This program reads /run/venusian and starts the appropriate service.

    More than one config file can be used. They are concatenated.
    The first matching record is used.

    The configuration has the form::

        dbus:
        - match:
            key1: pattern
            key2: another_pattern
          service: NAME
          user: venus

    Other keys are ignored. The user defaults to venus.
    A missing service skips this device; the next config file is used.
    service=null ignores this device.

    """
    logging.basicConfig(level=logging.WARNING if verbose == 0 else logging.INFO if verbose == 1 else logging.DEBUG)

    config = [ Path(f) for f in config ]

    h = Handler(config=config)
    try:
        anyio.run(h.run, backend="trio")
    except* KeyboardInterrupt:
        if verbose:
            raise
        print("Interrupted.", file=sys.stderr)


class Handler:
    bad_serial = re.compile(r"(\w)\1{6,}")

    def __init__(self, config: list[Path]):
        self.cfg_files = config
        self.read_cfg(first=True)
        self.buses = {}

        self.known = dict()

    async def run(self):
        self._udev = context = udev.Context()
        try:
            async with anyio.create_task_group() as self.tg:
                await self._run()
        finally:
            del self.tg
            del self._udev

    async def _run(self):
        monitor = udev.Monitor.from_netlink(self._udev)
        monitor.filter_by(subsystem="tty")  # others?

        logger.debug("processing existing devices")
        for dev in self._udev.list_devices(subsystem="tty",ID_BUS="usb",SUBSYSTEMS="platform|usb-serial"):
            await self.process(dev)
        logger.debug("waiting for changes")

        n_empty = 0
        fd = socket.fromfd(monitor.fileno(), socket.AF_NETLINK, socket.SOCK_STREAM)
        while True:
            await anyio.wait_socket_readable(fd)
            dev = monitor.poll(timeout=0)
            if dev is None:
                if n_empty > 3:
                    raise RuntimeError("No bus data")
                logger.debug("empty")
                n_empty += 1
                continue

            n_empty = 0
            name = dev.properties["DEVNAME"]
            if dev.action == "add":
                await self.process(dev)
            elif dev.action == "remove":
                await self.stop(name)
            else:
                logger.warning("Unknown action %r for %r", dev.action, name)

    def find_cfg(self, dev):
        prop = dev.properties
        def match1(rule: dict[str,str]) -> bool:
            for k,v in rule.items():
                if v is None:
                    if k in prop:
                        return False
                else:
                    try:
                        if not fnmatch(prop[k], v):
                            return False
                    except KeyError:
                        return False
            return True

        def match2(rule: dict):
            try:
                rules = rule["match"]
            except KeyError:
                return None
            if isinstance(rules, list):
                for r in rules:
                    if match1(r):
                        return True
                return False
            else:
                return match1(rules)

        for cfg in self.cfg:
            cfg = cfg.get("udev", [])
            for rule in cfg:
                m = match2(rule)
                if not m:
                    continue
                s = rule.get("service", False)
                if s is None:
                    return None,None
                elif s is False:
                    break
                return s, rule.get("user","venus")

        return None,None


    async def process(self, dev):
        name = dev.properties["DEVNAME"]
        service,user = self.find_cfg(dev)
        if service is None:
            logger.warning("Unknown device: %r\nMatch: %s\nService: %s", name, self.recommend_match(dev), self.recommend_service(dev))
            for k,v in dev.properties.items():
                logger.info("  %s=%r", k,v)
            return
        logger.info("Known device: %r: %s %s", name,service,user)
        await self.start(name,service, user)

    def recommend_match(self, dev):
        "return a text with match suggestions"
        p = dev.properties
        ser = p.get("ID_USB_SERIAL_SHORT")
        if ser is not None and not self.bad_serial.match(ser) and "234567" not in ser and "bcdefg" not in ser.lower():
            return f"ID_USB_SERIAL={p['ID_USB_SERIAL']}"
        path = p.get("ID_PATH_TAG")
        if path is not None:
            return f"(add wildcards): ID_PATH_TAG={path}"
        return f"(not optimal): DEVNAME={p['DEVNAME']}"

    def recommend_service(self, dev):
        p = dev.properties
        ve = p.get("VE_SERVICE")
        if ve is not None:
            return ve

    async def _get_bus(self, user):
        try:
            dbus = self.buses[user]
        except KeyError:
            return None
        else:
            while isinstance(dbus,anyio.Event):
                await dbus.wait()
                dbus = self.buses.get(user, None)
            return dbus

    async def _run_bus(self, user, *, task_status):
        uid = pwd.getpwnam(user).pw_uid
        bus = f"unix:path=/run/user/{uid}/bus"
        dbus = await self._get_bus(user)
        if dbus is not None:
            task_status.started(dbus)
            return

        self.buses[user] = evt = anyio.Event()
        try:
            async with MessageBus(bus).connect() as dbus:
                self.buses[user] = dbus
                evt.set()
                task_status.started(dbus)
                task_status = None

                await anyio.sleep_forever()
                # assuming that the bus reader will error out and kill us
        except Exception as exc:
            logger.exception("dbus link for %s died: %r", user, exc)
            if task_status is not None:
                task_status.started(None)

        finally:
            if self.buses.get(user, None) is dbus:
                del self.buses[user]

    async def get_bus(self, user):
        dbus = await self._get_bus(user)
        if dbus is None:
            dbus = await self.tg.start(self._run_bus, user)
        return dbus

    async def start(self, name, service, user, retry=False):
        if name in self.known:
            logger.error("KNOWN %s %s %s",service,user,name)
            return
        self.known[name] = (service, user)
        logger.error("START %s %s %s",service,user,name)
        dbus = await self.get_bus(user)
        breakpoint()
        pass



    async def stop(self, name):
        try:
            service,user = self.known.pop(name)
        except KeyError:
            return
        logger.error("STOP %s %s %s",service,user,name)

    def read_cfg(self, first:bool = False):
        cfg = [{}] * len(self.cfg_files) if first else self.cfg

        for n,(c,fn) in enumerate(zip(cfg, self.cfg_files)):
            ts = fn.stat().st_ctime
            if c.get("_t",0) == ts:
                continue

            with fn.open("r") as f:
                try:
                    cf = yload(f)
                    if not isinstance(cf, dict):
                        raise RuntimeError(f"YAML {fn !r} is not a mapping.")
                except Exception:
                    if prev is None:
                        raise  # first run must work
                    logger.exception("Reading %r", fn)
                    continue

            cf["_t"] = ts
            cfg[n] = cf

        self.cfg = cfg


if __name__ == "__main__":
    main()
